"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const url_1 = require("url");
const net = __importStar(require("net"));
const tls = __importStar(require("tls"));
const Attribute_1 = require("./Attribute");
const MessageParser_1 = require("./MessageParser");
const MessageResponseStatus_1 = require("./MessageResponseStatus");
const StatusCodeParser_1 = require("./StatusCodeParser");
const PagedResultsControl_1 = require("./controls/PagedResultsControl");
const messages_1 = require("./messages");
const FilterParser_1 = require("./FilterParser");
const filters_1 = require("./filters");
const MAX_MESSAGE_ID = Math.pow(2, 31) - 1;
const logDebug = debug_1.default('ldapts');
class Client {
    constructor(options) {
        this.messageId = 1;
        this.connected = false;
        this.messageParser = new MessageParser_1.MessageParser();
        this.messageDetailsByMessageId = {};
        this.clientOptions = options || {};
        if (!this.clientOptions.timeout) {
            this.clientOptions.timeout = 0;
        }
        if (!this.clientOptions.connectTimeout) {
            this.clientOptions.connectTimeout = 0;
        }
        this.clientOptions.strictDN = this.clientOptions.strictDN !== false;
        const parsedUrl = url_1.parse(options.url);
        if (!parsedUrl.protocol || !(parsedUrl.protocol === 'ldap:' || parsedUrl.protocol === 'ldaps:')) {
            throw new Error(`${options.url} is an invalid LDAP URL (protocol)`);
        }
        this.secure = parsedUrl.protocol === 'ldaps:';
        this.host = parsedUrl.hostname || 'localhost';
        if (parsedUrl.port) {
            this.port = Number(parsedUrl.port);
        }
        else if (this.secure) {
            this.port = 636;
        }
        else {
            this.port = 389;
        }
        this.messageParser.on('error', (err) => {
            if (err.messageDetails && err.messageDetails.messageId) {
                const messageDetails = this.messageDetailsByMessageId[err.messageDetails.messageId.toString()];
                if (messageDetails) {
                    delete this.messageDetailsByMessageId[err.messageDetails.messageId.toString()];
                    return messageDetails.reject(err);
                }
            }
            logDebug(err.stack);
        });
        this.messageParser.on('message', this._handleSendResponse.bind(this));
    }
    get isConnected() {
        return this.connected;
    }
    /**
     * Performs a simple authentication against the server.
     * @param {string|DN} dn
     * @param {string} [password]
     * @param {Control|Control[]} [controls]
     */
    async bind(dn, password, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.BindRequest({
            messageId: this._nextMessageId(),
            dn: typeof dn === 'string' ? dn : dn.toString(),
            password,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status, result.errorMessage);
        }
    }
    /**
     * Used to create a new entry in the directory
     * @param {string|DN} dn - The DN of the entry to add
     * @param {Attribute[]|Object} attributes - Array of attributes or object where keys are the name of each attribute
     * @param {Control|Control[]} [controls]
     */
    async add(dn, attributes, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        let attributesToAdd;
        if (Array.isArray(attributes)) {
            attributesToAdd = attributes;
        }
        else {
            attributesToAdd = [];
            for (const [key, value] of Object.entries(attributes)) {
                let values;
                if (Array.isArray(value)) {
                    values = value;
                }
                else {
                    values = [value];
                }
                attributesToAdd.push(new Attribute_1.Attribute({
                    type: key,
                    values,
                }));
            }
        }
        const req = new messages_1.AddRequest({
            messageId: this._nextMessageId(),
            dn: typeof dn === 'string' ? dn : dn.toString(),
            attributes: attributesToAdd,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status, result.errorMessage);
        }
    }
    /**
     * Compares an attribute/value pair with an entry on the LDAP server.
     * @param {string|DN} dn - The DN of the entry to compare attributes with
     * @param {string} attribute
     * @param {string} value
     * @param {Control|Control[]} [controls]
     */
    async compare(dn, attribute, value, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.CompareRequest({
            messageId: this._nextMessageId(),
            dn: typeof dn === 'string' ? dn : dn.toString(),
            attribute,
            value,
            controls,
        });
        const response = await this._send(req);
        switch (response.status) {
            case messages_1.CompareResult.compareTrue:
                return true;
            case messages_1.CompareResult.compareFalse:
                return false;
            default:
                throw StatusCodeParser_1.StatusCodeParser.parse(response.status, response.errorMessage);
        }
    }
    /**
     * Deletes an entry from the LDAP server.
     * @param {string|DN} dn - The DN of the entry to delete
     * @param {Control|Control[]} [controls]
     */
    async del(dn, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.DeleteRequest({
            messageId: this._nextMessageId(),
            dn: typeof dn === 'string' ? dn : dn.toString(),
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status, result.errorMessage);
        }
    }
    /**
     * Performs an extended operation on the LDAP server.
     * @param {string} oid - The object identifier (OID) of the extended operation to perform
     * @param {string} [value]
     * @param {Control|Control[]} [controls]
     */
    async exop(oid, value, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.ExtendedRequest({
            messageId: this._nextMessageId(),
            oid,
            value,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status, result.errorMessage);
        }
        return {
            oid: result.oid,
            value: result.value,
        };
    }
    /**
     * Performs an LDAP modify against the server.
     * @param {string|DN} dn - The DN of the entry to modify
     * @param {Change|Change[]} changes
     * @param {Control|Control[]} [controls]
     */
    async modify(dn, changes, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (changes && !Array.isArray(changes)) {
            // tslint:disable-next-line:no-parameter-reassignment
            changes = [changes];
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        const req = new messages_1.ModifyRequest({
            messageId: this._nextMessageId(),
            dn: typeof dn === 'string' ? dn : dn.toString(),
            changes,
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status, result.errorMessage);
        }
    }
    /**
     * Performs an LDAP modifyDN against the server.
     * @param {string|DN} dn - The DN of the entry to modify
     * @param {string|DN} newDN - The new DN to move this entry to
     * @param {Control|Control[]} [controls]
     */
    async modifyDN(dn, newDN, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls && !Array.isArray(controls)) {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [controls];
        }
        // TODO: parse newDN to determine if newSuperior should be specified
        const req = new messages_1.ModifyDNRequest({
            messageId: this._nextMessageId(),
            dn: typeof dn === 'string' ? dn : dn.toString(),
            deleteOldRdn: true,
            newRdn: typeof newDN === 'string' ? newDN : newDN.toString(),
            controls,
        });
        const result = await this._send(req);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status, result.errorMessage);
        }
    }
    /**
     * Performs an LDAP search against the server.
     *
     * @param {string|DN} baseDN - This specifies the base of the subtree in which the search is to be constrained.
     * @param {SearchOptions} [options]
     * @param {string|Filter} [options.filter=(objectclass=*)] - The filter of the search request. It must conform to the LDAP filter syntax specified in RFC4515
     * @param {string} [options.scope='sub'] - Specifies how broad the search context is:
     * - base - Indicates that only the entry specified as the search base should be considered. None of its subordinates will be considered.
     * - one - Indicates that only the immediate children of the entry specified as the search base should be considered. The base entry itself should not be considered, nor any descendants of the immediate children of the base entry.
     * - sub - Indicates that the entry specified as the search base, and all of its subordinates to any depth, should be considered.
     * - children - Indicates that the entry specified by the search base should not be considered, but all of its subordinates to any depth should be considered.
     * @param {string} [options.derefAliases='never'] - Specifies how the server must treat references to other entries:
     * - never - Never dereferences entries, returns alias objects instead. The alias contains the reference to the real entry.
     * - always - Always returns the referenced entries, not the alias object.
     * - search - While searching subordinates of the base object, dereferences any alias within the search scope. Dereferenced objects become the bases of further search scopes where the Search operation is also applied by the server. The server should eliminate duplicate entries that arise due to alias dereferencing while searching.
     * - find - Dereferences aliases in locating the base object of the search, but not when searching subordinates of the base object.
     * @param {boolean} [options.returnAttributeValues=true] - If true, attribute values should be included in the entries that are returned; otherwise entries that match the search criteria should be returned containing only the attribute descriptions for the attributes contained in that entry but should not include the values for those attributes.
     * @param {number} [options.sizeLimit=0] - This specifies the maximum number of entries that should be returned from the search. A value of zero indicates no limit. Note that the server may also impose a size limit for the search operation, and in that case the smaller of the client-requested and server-imposed size limits will be enforced.
     * @param {number} [options.timeLimit=10] - This specifies the maximum length of time, in seconds, that the server should spend processing the search. A value of zero indicates no limit. Note that the server may also impose a time limit for the search operation, and in that case the smaller of the client-requested and server-imposed time limits will be enforced.
     * @param {boolean|SearchPageOptions} [options.paged=false] - Used to allow paging and specify the page size
     * @param {string[]} [options.attributes] - A set of attributes to request for inclusion in entries that match the search criteria and are returned to the client. If a specific set of attribute descriptions are listed, then only those attributes should be included in matching entries. The special value “*” indicates that all user attributes should be included in matching entries. The special value “+” indicates that all operational attributes should be included in matching entries. The special value “1.1” indicates that no attributes should be included in matching entries. Some servers may also support the ability to use the “@” symbol followed by an object class name (e.g., “@inetOrgPerson”) to request all attributes associated with that object class. If the set of attributes to request is empty, then the server should behave as if the value “*” was specified to request that all user attributes be included in entries that are returned.
     * @param {Control|Control[]} [controls]
     */
    async search(baseDN, options = {}, controls) {
        if (!this.connected) {
            await this._connect();
        }
        if (controls) {
            if (Array.isArray(controls)) {
                // tslint:disable-next-line:no-parameter-reassignment
                controls = controls.slice(0);
            }
            else {
                // tslint:disable-next-line:no-parameter-reassignment
                controls = [controls];
            }
            // Make sure PagedResultsControl is not specified since it's handled internally
            for (const control of controls) {
                if (control instanceof PagedResultsControl_1.PagedResultsControl) {
                    throw new Error('Should not specify PagedResultsControl');
                }
            }
        }
        else {
            // tslint:disable-next-line:no-parameter-reassignment
            controls = [];
        }
        let pageSize = 100;
        if (typeof options.paged === 'object' && options.paged.pageSize) {
            pageSize = options.paged.pageSize;
        }
        else if (options.sizeLimit && options.sizeLimit > 1) {
            // According to the RFC, servers should ignore the paging control if
            // pageSize >= sizelimit.  Some might still send results, but it's safer
            // to stay under that figure when assigning a default value.
            pageSize = options.sizeLimit - 1;
        }
        let pagedResultsControl;
        const shouldPage = !!options.paged;
        if (shouldPage) {
            pagedResultsControl = new PagedResultsControl_1.PagedResultsControl({
                value: {
                    size: pageSize,
                },
            });
            controls.push(pagedResultsControl);
        }
        let filter;
        if (options.filter) {
            if (typeof options.filter === 'string') {
                filter = FilterParser_1.FilterParser.parseString(options.filter);
            }
            else {
                filter = options.filter;
            }
        }
        else {
            filter = new filters_1.PresenceFilter({ attribute: 'objectclass' });
        }
        const searchRequest = new messages_1.SearchRequest({
            messageId: -1,
            baseDN: typeof baseDN === 'string' ? baseDN : baseDN.toString(),
            scope: options.scope,
            filter,
            attributes: options.attributes,
            returnAttributeValues: options.returnAttributeValues,
            sizeLimit: options.sizeLimit,
            timeLimit: options.timeLimit,
            controls,
        });
        const searchResult = {
            searchEntries: [],
            searchReferences: [],
        };
        await this._sendSearch(searchRequest, searchResult, shouldPage, pageSize, pagedResultsControl);
        return searchResult;
    }
    /**
     * Unbinds this client from the LDAP server.
     * @returns {void|Promise} void if not connected; otherwise returns a promise to the request to disconnect
     */
    async unbind() {
        if (!this.connected || !this.socket) {
            return;
        }
        const req = new messages_1.UnbindRequest({
            messageId: this._nextMessageId(),
        });
        await this._send(req);
    }
    async _sendSearch(searchRequest, searchResult, paged, pageSize, pagedResultsControl) {
        searchRequest.messageId = this._nextMessageId();
        const result = await this._send(searchRequest);
        if (result.status !== MessageResponseStatus_1.MessageResponseStatus.Success && !(result.status === MessageResponseStatus_1.MessageResponseStatus.SizeLimitExceeded && searchRequest.sizeLimit)) {
            throw StatusCodeParser_1.StatusCodeParser.parse(result.status, result.errorMessage);
        }
        for (const searchEntry of result.searchEntries) {
            searchResult.searchEntries.push(searchEntry.toObject(searchRequest.attributes));
        }
        for (const searchReference of result.searchReferences) {
            searchResult.searchReferences.push(...searchReference.uris);
        }
        // Recursively search if paging is specified
        if (paged && (result.searchEntries.length || result.searchReferences.length) && pagedResultsControl) {
            let pagedResultsFromResponse;
            for (const control of (result.controls || [])) {
                if (control instanceof PagedResultsControl_1.PagedResultsControl) {
                    pagedResultsFromResponse = control;
                    break;
                }
            }
            if (pagedResultsFromResponse && pagedResultsFromResponse.value && pagedResultsFromResponse.value.cookie && pagedResultsFromResponse.value.cookie.length) {
                // Recursively keep searching
                pagedResultsControl.value = pagedResultsControl.value || {
                    size: pageSize,
                };
                pagedResultsControl.value.cookie = pagedResultsFromResponse.value.cookie;
                await this._sendSearch(searchRequest, searchResult, paged, pageSize, pagedResultsControl);
            }
        }
    }
    _nextMessageId() {
        this.messageId += 1;
        if (this.messageId >= MAX_MESSAGE_ID) {
            this.messageId = 1;
        }
        return this.messageId;
    }
    /**
     * Open the socket connection
     * @returns {Promise<void>}
     * @private
     */
    _connect() {
        if (this.connected) {
            return true;
        }
        return new Promise((resolve, reject) => {
            if (this.secure) {
                this.socket = tls.connect(this.port, this.host, this.clientOptions.tlsOptions);
                this.socket.once('secureConnect', () => {
                    this._onConnect(resolve);
                });
            }
            else {
                this.socket = net.connect(this.port, this.host);
                this.socket.once('connect', () => {
                    this._onConnect(resolve);
                });
            }
            this.socket.once('error', (err) => {
                if (this.connectTimer) {
                    clearTimeout(this.connectTimer);
                    delete this.connectTimer;
                }
                reject(err);
            });
            if (this.clientOptions.connectTimeout) {
                this.connectTimer = setTimeout(() => {
                    if (this.socket && (!this.socket.readable || !this.socket.writable)) {
                        this.connected = false;
                        this.socket.destroy();
                        delete this.socket;
                    }
                    return reject(new Error('Connection timeout'));
                }, this.clientOptions.connectTimeout);
            }
        });
    }
    _onConnect(next) {
        clearTimeout(this.connectTimer);
        // Clear out event listeners from _connect()
        this.socket.removeAllListeners('error');
        this.socket.removeAllListeners('connect');
        this.socket.removeAllListeners('secureConnect');
        this.connected = true;
        // region Socket events handlers
        const socketError = (err) => {
            // Clean up any pending messages
            for (const [key, messageDetails] of Object.entries(this.messageDetailsByMessageId)) {
                if (messageDetails.message instanceof messages_1.UnbindRequest) {
                    // Consider unbind as success since the connection is closed.
                    messageDetails.resolve();
                }
                else {
                    messageDetails.reject(new Error(`Socket error. Message type: ${messageDetails.message.constructor.name} (0x${messageDetails.message.protocolOperation.toString(16)})\n${err.message || err.stack || 'Unknown'}`));
                }
                delete this.messageDetailsByMessageId[key];
            }
            this.socket.destroy();
        };
        function socketEnd() {
            if (this) {
                // Acknowledge to other end of the connection that the connection is ended.
                this.end();
            }
        }
        function socketTimeout() {
            if (this) {
                // Acknowledge to other end of the connection that the connection is ended.
                this.end();
            }
        }
        const socketData = (data) => {
            if (this.messageParser) {
                this.messageParser.read(data);
            }
        };
        // tslint:disable-next-line:no-this-assignment
        const clientInstance = this;
        function socketClose() {
            if (this) {
                this.removeListener('error', socketError);
                this.removeListener('close', socketClose);
                this.removeListener('data', socketData);
                this.removeListener('end', socketEnd);
                this.removeListener('timeout', socketTimeout);
            }
            if (this === clientInstance.socket) {
                clientInstance.connected = false;
                delete clientInstance.socket;
            }
            // Clean up any pending messages
            for (const [key, messageDetails] of Object.entries(clientInstance.messageDetailsByMessageId)) {
                if (messageDetails.socket === this) {
                    if (messageDetails.message instanceof messages_1.UnbindRequest) {
                        // Consider unbind as success since the connection is closed.
                        messageDetails.resolve();
                    }
                    else {
                        messageDetails.reject(new Error(`Connection closed before message response was received. Message type: ${messageDetails.message.constructor.name} (0x${messageDetails.message.protocolOperation.toString(16)})`));
                    }
                    delete clientInstance.messageDetailsByMessageId[key];
                }
            }
        }
        // endregion
        // Hook up event listeners
        this.socket.on('error', socketError);
        this.socket.on('close', socketClose);
        this.socket.on('data', socketData);
        this.socket.on('end', socketEnd);
        this.socket.on('timeout', socketTimeout);
        return next();
    }
    _endSocket(socket) {
        if (socket === this.socket) {
            this.connected = false;
        }
        // Ignore any error since the connection is being closed
        socket.removeAllListeners('error');
        // tslint:disable-next-line:no-empty
        socket.on('error', () => { });
        socket.end();
    }
    /**
     * Sends request message to the ldap server over the connected socket.
     * Each message request is given a unique id (messageId), used to identify the associated response when it is sent back over the socket.
     * @returns {Promise<Message>}
     * @private
     */
    _send(message) {
        if (!this.connected || !this.socket) {
            throw new Error('Socket connection not established');
        }
        /* tslint:disable:no-empty */
        let messageResolve = () => { };
        let messageReject = () => { };
        /* tslint:enable:no-empty */
        const sendPromise = new Promise((resolve, reject) => {
            // @ts-ignore
            messageResolve = resolve;
            messageReject = reject;
        });
        this.messageDetailsByMessageId[message.messageId.toString()] = {
            message,
            resolve: messageResolve,
            reject: messageReject,
            timeoutTimer: this.clientOptions.timeout ? setTimeout(() => {
                const messageDetails = this.messageDetailsByMessageId[message.messageId.toString()];
                if (messageDetails) {
                    this._endSocket(messageDetails.socket);
                    return messageReject(new Error(`${message.constructor.name}: Operation timed out`));
                }
            }, this.clientOptions.timeout) : null,
            socket: this.socket,
        };
        // Send the message to the socket
        logDebug(`Sending message: ${message}`);
        this.socket.write(message.write(), () => {
            if (message instanceof messages_1.AbandonRequest) {
                logDebug(`Abandoned message: ${message.messageId}`);
                delete this.messageDetailsByMessageId[message.messageId.toString()];
                messageResolve();
            }
            else if (message instanceof messages_1.UnbindRequest) {
                logDebug(`Unbind success. Ending socket`);
                this._endSocket(this.socket);
            }
            else {
                // NOTE: messageResolve will be called as 'data' events come from the socket
                logDebug('Message sent successfully.');
            }
        });
        return sendPromise;
    }
    _handleSendResponse(message) {
        const messageDetails = this.messageDetailsByMessageId[message.messageId.toString()];
        if (messageDetails) {
            // When performing a search, an arbitrary number of SearchEntry and SearchReference messages come through with the
            // same messageId as the SearchRequest. Finally, a SearchResponse will come through to complete the request.
            if (message instanceof messages_1.SearchEntry) {
                messageDetails.searchEntries = messageDetails.searchEntries || [];
                messageDetails.searchEntries.push(message);
            }
            else if (message instanceof messages_1.SearchReference) {
                messageDetails.searchReferences = messageDetails.searchReferences || [];
                messageDetails.searchReferences.push(message);
            }
            else if (message instanceof messages_1.SearchResponse) {
                // Assign any previously collected entries & references
                if (messageDetails.searchEntries) {
                    message.searchEntries.push(...messageDetails.searchEntries);
                }
                if (messageDetails.searchReferences) {
                    message.searchReferences.push(...messageDetails.searchReferences);
                }
                delete this.messageDetailsByMessageId[message.messageId.toString()];
                messageDetails.resolve(message);
            }
            else {
                delete this.messageDetailsByMessageId[message.messageId.toString()];
                messageDetails.resolve(message);
            }
        }
        else {
            logDebug(`Unable to find details related to message response: ${message}`);
        }
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map